{"version":3,"file":"index.esm.js","sources":["../src/util/constants.ts","../src/util/errors.ts","../src/helpers/extract-app-config.ts","../src/api/common.ts","../src/api/create-installation.ts","../src/util/sleep.ts","../src/helpers/buffer-to-base64-url-safe.ts","../src/helpers/generate-fid.ts","../src/helpers/idb-manager.ts","../src/helpers/get-installation-entry.ts","../src/api/generate-auth-token.ts","../src/helpers/refresh-auth-token.ts","../src/functions/get-id.ts","../src/functions/get-token.ts","../src/api/delete-installation.ts","../src/functions/delete-installation.ts","../src/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { version } from '../../package.json';\n\nexport const PENDING_TIMEOUT_MS = 10000;\n\nexport const PACKAGE_VERSION = `w:${version}`;\nexport const INTERNAL_AUTH_VERSION = 'FIS_v2';\n\nexport const INSTALLATIONS_API_URL =\n  'https://firebaseinstallations.googleapis.com/v1';\n\nexport const TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1000; // One hour\n\nexport const SERVICE = 'installations';\nexport const SERVICE_NAME = 'Installations';\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorFactory, FirebaseError } from '@firebase/util';\nimport { SERVICE, SERVICE_NAME } from './constants';\n\nexport const enum ErrorCode {\n  MISSING_APP_CONFIG_VALUES = 'missing-app-config-values',\n  CREATE_INSTALLATION_FAILED = 'create-installation-failed',\n  GENERATE_TOKEN_FAILED = 'generate-token-failed',\n  NOT_REGISTERED = 'not-registered',\n  INSTALLATION_NOT_FOUND = 'installation-not-found',\n  REQUEST_FAILED = 'request-failed',\n  APP_OFFLINE = 'app-offline',\n  DELETE_PENDING_REGISTRATION = 'delete-pending-registration'\n}\n\nconst ERROR_DESCRIPTION_MAP: { readonly [key in ErrorCode]: string } = {\n  [ErrorCode.MISSING_APP_CONFIG_VALUES]: 'Missing App configuration values.',\n  [ErrorCode.CREATE_INSTALLATION_FAILED]:\n    'Could not register Firebase Installation.',\n  [ErrorCode.GENERATE_TOKEN_FAILED]: 'Could not generate Auth Token.',\n  [ErrorCode.NOT_REGISTERED]: 'Firebase Installation is not registered.',\n  [ErrorCode.INSTALLATION_NOT_FOUND]: 'Firebase Installation not found.',\n  [ErrorCode.REQUEST_FAILED]:\n    '{$requestName} request failed with error \"{$serverCode} {$serverStatus}: {$serverMessage}\"',\n  [ErrorCode.APP_OFFLINE]: 'Could not process request. Application offline.',\n  [ErrorCode.DELETE_PENDING_REGISTRATION]:\n    \"Can't delete installation while there is a pending registration request.\"\n};\n\ninterface ErrorParams {\n  [ErrorCode.REQUEST_FAILED]: {\n    requestName: string;\n  } & ServerErrorData;\n}\n\nexport const ERROR_FACTORY = new ErrorFactory<ErrorCode, ErrorParams>(\n  SERVICE,\n  SERVICE_NAME,\n  ERROR_DESCRIPTION_MAP\n);\n\nexport interface ServerErrorData {\n  serverCode: number;\n  serverMessage: string;\n  serverStatus: string;\n}\n\nexport type ServerError = FirebaseError & ServerErrorData;\n\n/** Returns true if error is a FirebaseError that is based on an error from the server. */\nexport function isServerError(error: unknown): error is ServerError {\n  return (\n    error instanceof FirebaseError &&\n    error.code.includes(ErrorCode.REQUEST_FAILED)\n  );\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app-types';\nimport { AppConfig } from '../interfaces/app-config';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\n\nexport function extractAppConfig(app: FirebaseApp): AppConfig {\n  if (!app || !app.options) {\n    throw ERROR_FACTORY.create(ErrorCode.MISSING_APP_CONFIG_VALUES);\n  }\n\n  const appName = app.name;\n  const { projectId, apiKey, appId } = app.options;\n\n  if (!appName || !projectId || !apiKey || !appId) {\n    throw ERROR_FACTORY.create(ErrorCode.MISSING_APP_CONFIG_VALUES);\n  }\n\n  return { appName, projectId, apiKey, appId };\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseError } from '@firebase/util';\nimport { GenerateAuthTokenResponse } from '../interfaces/api-response';\nimport { AppConfig } from '../interfaces/app-config';\nimport {\n  CompletedAuthToken,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport {\n  INSTALLATIONS_API_URL,\n  INTERNAL_AUTH_VERSION\n} from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\n\nexport function getInstallationsEndpoint({ projectId }: AppConfig): string {\n  return `${INSTALLATIONS_API_URL}/projects/${projectId}/installations`;\n}\n\nexport function extractAuthTokenInfoFromResponse(\n  response: GenerateAuthTokenResponse\n): CompletedAuthToken {\n  return {\n    token: response.token,\n    requestStatus: RequestStatus.COMPLETED,\n    expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),\n    creationTime: Date.now()\n  };\n}\n\nexport async function getErrorFromResponse(\n  requestName: string,\n  response: Response\n): Promise<FirebaseError> {\n  const responseJson: ErrorResponse = await response.json();\n  const errorData = responseJson.error;\n  return ERROR_FACTORY.create(ErrorCode.REQUEST_FAILED, {\n    requestName,\n    serverCode: errorData.code,\n    serverMessage: errorData.message,\n    serverStatus: errorData.status\n  });\n}\n\nexport function getHeaders({ apiKey }: AppConfig): Headers {\n  return new Headers({\n    'Content-Type': 'application/json',\n    Accept: 'application/json',\n    'x-goog-api-key': apiKey\n  });\n}\n\nexport function getHeadersWithAuth(\n  appConfig: AppConfig,\n  { refreshToken }: RegisteredInstallationEntry\n): Headers {\n  const headers = getHeaders(appConfig);\n  headers.append('Authorization', getAuthorizationHeader(refreshToken));\n  return headers;\n}\n\nexport interface ErrorResponse {\n  error: {\n    code: number;\n    message: string;\n    status: string;\n  };\n}\n\n/**\n * Calls the passed in fetch wrapper and returns the response.\n * If the returned response has a status of 5xx, re-runs the function once and\n * returns the response.\n */\nexport async function retryIfServerError(\n  fn: () => Promise<Response>\n): Promise<Response> {\n  const result = await fn();\n\n  if (result.status >= 500 && result.status < 600) {\n    // Internal Server Error. Retry request.\n    return fn();\n  }\n\n  return result;\n}\n\nfunction getExpiresInFromResponseExpiresIn(responseExpiresIn: string): number {\n  // This works because the server will never respond with fractions of a second.\n  return Number(responseExpiresIn.replace('s', '000'));\n}\n\nfunction getAuthorizationHeader(refreshToken: string): string {\n  return `${INTERNAL_AUTH_VERSION} ${refreshToken}`;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CreateInstallationResponse } from '../interfaces/api-response';\nimport { AppConfig } from '../interfaces/app-config';\nimport {\n  InProgressInstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { INTERNAL_AUTH_VERSION, PACKAGE_VERSION } from '../util/constants';\nimport {\n  extractAuthTokenInfoFromResponse,\n  getErrorFromResponse,\n  getHeaders,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\n\nexport async function createInstallation(\n  appConfig: AppConfig,\n  { fid }: InProgressInstallationEntry\n): Promise<RegisteredInstallationEntry> {\n  const endpoint = getInstallationsEndpoint(appConfig);\n\n  const headers = getHeaders(appConfig);\n  const body = {\n    fid,\n    authVersion: INTERNAL_AUTH_VERSION,\n    appId: appConfig.appId,\n    sdkVersion: PACKAGE_VERSION\n  };\n\n  const request: RequestInit = {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body)\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (response.ok) {\n    const responseValue: CreateInstallationResponse = await response.json();\n    const registeredInstallationEntry: RegisteredInstallationEntry = {\n      fid: responseValue.fid || fid,\n      registrationStatus: RequestStatus.COMPLETED,\n      refreshToken: responseValue.refreshToken,\n      authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)\n    };\n    return registeredInstallationEntry;\n  } else {\n    throw await getErrorFromResponse('Create Installation', response);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** Returns a promise that resolves after given time passes. */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise<void>(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function bufferToBase64UrlSafe(array: Uint8Array): string {\n  const b64 = btoa(String.fromCharCode(...array));\n  return b64.replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { bufferToBase64UrlSafe } from './buffer-to-base64-url-safe';\n\nexport const VALID_FID_PATTERN = /^[cdef][\\w-]{21}$/;\nexport const INVALID_FID = '';\n\n/**\n * Generates a new FID using random values from Web Crypto API.\n * Returns an empty string if FID generation fails for any reason.\n */\nexport function generateFid(): string {\n  try {\n    // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5\n    // bytes. our implementation generates a 17 byte array instead.\n    const fidByteArray = new Uint8Array(17);\n    const crypto =\n      self.crypto || ((self as unknown) as { msCrypto: Crypto }).msCrypto;\n    crypto.getRandomValues(fidByteArray);\n\n    // Replace the first 4 random bits with the constant FID header of 0b0111.\n    fidByteArray[0] = 0b01110000 + (fidByteArray[0] % 0b00010000);\n\n    const fid = encode(fidByteArray);\n\n    return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;\n  } catch {\n    // FID generation errored\n    return INVALID_FID;\n  }\n}\n\n/** Converts a FID Uint8Array to a base64 string representation. */\nfunction encode(fidByteArray: Uint8Array): string {\n  const b64String = bufferToBase64UrlSafe(fidByteArray);\n\n  // Remove the 23rd character that was added because of the extra 4 bits at the\n  // end of our 17 byte array, and the '=' padding.\n  return b64String.substr(0, 22);\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DB, openDb } from 'idb';\nimport { AppConfig } from '../interfaces/app-config';\n\nconst DATABASE_NAME = 'firebase-installations-database';\nconst DATABASE_VERSION = 1;\nconst OBJECT_STORE_NAME = 'firebase-installations-store';\n\nlet dbPromise: Promise<DB> | null = null;\nfunction getDbPromise(): Promise<DB> {\n  if (!dbPromise) {\n    dbPromise = openDb(DATABASE_NAME, DATABASE_VERSION, upgradeDB => {\n      // We don't use 'break' in this switch statement, the fall-through\n      // behavior is what we want, because if there are multiple versions between\n      // the old version and the current version, we want ALL the migrations\n      // that correspond to those versions to run, not only the last one.\n      // eslint-disable-next-line default-case\n      switch (upgradeDB.oldVersion) {\n        case 0:\n          upgradeDB.createObjectStore(OBJECT_STORE_NAME);\n      }\n    });\n  }\n  return dbPromise;\n}\n\n/** Gets record(s) from the objectStore that match the given key. */\nexport async function get(appConfig: AppConfig): Promise<unknown> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  return db\n    .transaction(OBJECT_STORE_NAME)\n    .objectStore(OBJECT_STORE_NAME)\n    .get(key);\n}\n\n/** Assigns or overwrites the record for the given key with the given value. */\nexport async function set<ValueType>(\n  appConfig: AppConfig,\n  value: ValueType\n): Promise<ValueType> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  await tx.objectStore(OBJECT_STORE_NAME).put(value, key);\n  await tx.complete;\n  return value;\n}\n\n/** Removes record(s) from the objectStore that match the given key. */\nexport async function remove(appConfig: AppConfig): Promise<void> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  await tx.objectStore(OBJECT_STORE_NAME).delete(key);\n  await tx.complete;\n}\n\n/**\n * Atomically updates a record with the result of updateFn, which gets\n * called with the current value. If newValue is undefined, the record is\n * deleted instead.\n * @return Updated value\n */\nexport async function update<OldType, NewType>(\n  appConfig: AppConfig,\n  updateFn: (previousValue: OldType | undefined) => NewType\n): Promise<NewType> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  const store = tx.objectStore(OBJECT_STORE_NAME);\n  const oldValue = await store.get(key);\n  const newValue = updateFn(oldValue);\n\n  if (newValue === oldValue) {\n    return newValue;\n  }\n\n  if (newValue === undefined) {\n    await store.delete(key);\n  } else {\n    await store.put(newValue, key);\n  }\n\n  await tx.complete;\n  return newValue;\n}\n\nexport async function clear(): Promise<void> {\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  await tx.objectStore(OBJECT_STORE_NAME).clear();\n  await tx.complete;\n}\n\nfunction getKey(appConfig: AppConfig): string {\n  return `${appConfig.appName}!${appConfig.appId}`;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createInstallation } from '../api/create-installation';\nimport { AppConfig } from '../interfaces/app-config';\nimport {\n  InProgressInstallationEntry,\n  InstallationEntry,\n  RequestStatus,\n  RegisteredInstallationEntry\n} from '../interfaces/installation-entry';\nimport { PENDING_TIMEOUT_MS } from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode, isServerError } from '../util/errors';\nimport { sleep } from '../util/sleep';\nimport { generateFid, INVALID_FID } from './generate-fid';\nimport { remove, set, update } from './idb-manager';\n\nexport interface InstallationEntryWithRegistrationPromise {\n  installationEntry: InstallationEntry;\n  registrationPromise?: Promise<RegisteredInstallationEntry>;\n}\n\n/**\n * Updates and returns the InstallationEntry from the database.\n * Also triggers a registration request if it is necessary and possible.\n */\nexport async function getInstallationEntry(\n  appConfig: AppConfig\n): Promise<InstallationEntryWithRegistrationPromise> {\n  let registrationPromise: Promise<RegisteredInstallationEntry> | undefined;\n\n  const installationEntry = await update(\n    appConfig,\n    (oldEntry?: InstallationEntry): InstallationEntry => {\n      const installationEntry = updateOrCreateInstallationEntry(oldEntry);\n      const entryWithPromise = triggerRegistrationIfNecessary(\n        appConfig,\n        installationEntry\n      );\n      registrationPromise = entryWithPromise.registrationPromise;\n      return entryWithPromise.installationEntry;\n    }\n  );\n\n  if (installationEntry.fid === INVALID_FID) {\n    // FID generation failed. Waiting for the FID from the server.\n    return { installationEntry: await registrationPromise! };\n  }\n\n  return {\n    installationEntry,\n    registrationPromise\n  };\n}\n\nfunction updateOrCreateInstallationEntry(\n  oldEntry: InstallationEntry | undefined\n): InstallationEntry {\n  const entry: InstallationEntry = oldEntry || {\n    fid: generateFid(),\n    registrationStatus: RequestStatus.NOT_STARTED\n  };\n\n  if (hasInstallationRequestTimedOut(entry)) {\n    return {\n      fid: entry.fid,\n      registrationStatus: RequestStatus.NOT_STARTED\n    };\n  }\n\n  return entry;\n}\n\n/**\n * If the Firebase Installation is not registered yet, this will trigger the registration\n * and return an InProgressInstallationEntry.\n */\nfunction triggerRegistrationIfNecessary(\n  appConfig: AppConfig,\n  installationEntry: InstallationEntry\n): InstallationEntryWithRegistrationPromise {\n  if (installationEntry.registrationStatus === RequestStatus.NOT_STARTED) {\n    if (!navigator.onLine) {\n      // Registration required but app is offline.\n      const registrationPromiseWithError = Promise.reject(\n        ERROR_FACTORY.create(ErrorCode.APP_OFFLINE)\n      );\n      return {\n        installationEntry,\n        registrationPromise: registrationPromiseWithError\n      };\n    }\n\n    // Try registering. Change status to IN_PROGRESS.\n    const inProgressEntry: InProgressInstallationEntry = {\n      fid: installationEntry.fid,\n      registrationStatus: RequestStatus.IN_PROGRESS,\n      registrationTime: Date.now()\n    };\n    const registrationPromise = registerInstallation(\n      appConfig,\n      inProgressEntry\n    );\n    return { installationEntry: inProgressEntry, registrationPromise };\n  } else if (\n    installationEntry.registrationStatus === RequestStatus.IN_PROGRESS\n  ) {\n    return {\n      installationEntry,\n      registrationPromise: waitUntilFidRegistration(appConfig)\n    };\n  } else {\n    return { installationEntry };\n  }\n}\n\n/** This will be executed only once for each new Firebase Installation. */\nasync function registerInstallation(\n  appConfig: AppConfig,\n  installationEntry: InProgressInstallationEntry\n): Promise<RegisteredInstallationEntry> {\n  try {\n    const registeredInstallationEntry = await createInstallation(\n      appConfig,\n      installationEntry\n    );\n    return set(appConfig, registeredInstallationEntry);\n  } catch (e) {\n    if (isServerError(e) && e.serverCode === 409) {\n      // Server returned a \"FID can not be used\" error.\n      // Generate a new ID next time.\n      await remove(appConfig);\n    } else {\n      // Registration failed. Set FID as not registered.\n      await set(appConfig, {\n        fid: installationEntry.fid,\n        registrationStatus: RequestStatus.NOT_STARTED\n      });\n    }\n    throw e;\n  }\n}\n\n/** Call if FID registration is pending. */\nasync function waitUntilFidRegistration(\n  appConfig: AppConfig\n): Promise<RegisteredInstallationEntry> {\n  // Unfortunately, there is no way of reliably observing when a value in\n  // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n  // so we need to poll.\n\n  let entry: InstallationEntry = await updateInstallationRequest(appConfig);\n  while (entry.registrationStatus === RequestStatus.IN_PROGRESS) {\n    // createInstallation request still in progress.\n    await sleep(100);\n\n    entry = await updateInstallationRequest(appConfig);\n  }\n\n  if (entry.registrationStatus === RequestStatus.NOT_STARTED) {\n    throw ERROR_FACTORY.create(ErrorCode.CREATE_INSTALLATION_FAILED);\n  }\n\n  return entry;\n}\n\n/**\n * Called only if there is a CreateInstallation request in progress.\n *\n * Updates the InstallationEntry in the DB based on the status of the\n * CreateInstallation request.\n *\n * Returns the updated InstallationEntry.\n */\nfunction updateInstallationRequest(\n  appConfig: AppConfig\n): Promise<InstallationEntry> {\n  return update(\n    appConfig,\n    (oldEntry?: InstallationEntry): InstallationEntry => {\n      if (!oldEntry) {\n        throw ERROR_FACTORY.create(ErrorCode.INSTALLATION_NOT_FOUND);\n      }\n\n      if (hasInstallationRequestTimedOut(oldEntry)) {\n        return {\n          fid: oldEntry.fid,\n          registrationStatus: RequestStatus.NOT_STARTED\n        };\n      }\n\n      return oldEntry;\n    }\n  );\n}\n\nfunction hasInstallationRequestTimedOut(\n  installationEntry: InstallationEntry\n): boolean {\n  return (\n    installationEntry.registrationStatus === RequestStatus.IN_PROGRESS &&\n    installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now()\n  );\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GenerateAuthTokenResponse } from '../interfaces/api-response';\nimport { AppConfig } from '../interfaces/app-config';\nimport {\n  CompletedAuthToken,\n  RegisteredInstallationEntry\n} from '../interfaces/installation-entry';\nimport { PACKAGE_VERSION } from '../util/constants';\nimport {\n  extractAuthTokenInfoFromResponse,\n  getErrorFromResponse,\n  getHeadersWithAuth,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\n\nexport async function generateAuthToken(\n  appConfig: AppConfig,\n  installationEntry: RegisteredInstallationEntry\n): Promise<CompletedAuthToken> {\n  const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);\n\n  const headers = getHeadersWithAuth(appConfig, installationEntry);\n  const body = {\n    installation: {\n      sdkVersion: PACKAGE_VERSION\n    }\n  };\n\n  const request: RequestInit = {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body)\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (response.ok) {\n    const responseValue: GenerateAuthTokenResponse = await response.json();\n    const completedAuthToken: CompletedAuthToken = extractAuthTokenInfoFromResponse(\n      responseValue\n    );\n    return completedAuthToken;\n  } else {\n    throw await getErrorFromResponse('Generate Auth Token', response);\n  }\n}\n\nfunction getGenerateAuthTokenEndpoint(\n  appConfig: AppConfig,\n  { fid }: RegisteredInstallationEntry\n): string {\n  return `${getInstallationsEndpoint(appConfig)}/${fid}/authTokens:generate`;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { generateAuthToken } from '../api/generate-auth-token';\nimport { AppConfig } from '../interfaces/app-config';\nimport {\n  AuthToken,\n  CompletedAuthToken,\n  InProgressAuthToken,\n  InstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { PENDING_TIMEOUT_MS, TOKEN_EXPIRATION_BUFFER } from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode, isServerError } from '../util/errors';\nimport { sleep } from '../util/sleep';\nimport { remove, set, update } from './idb-manager';\n\n/**\n * Returns a valid authentication token for the installation. Generates a new\n * token if one doesn't exist, is expired or about to expire.\n *\n * Should only be called if the Firebase Installation is registered.\n */\nexport async function refreshAuthToken(appConfig: AppConfig): Promise<string> {\n  let tokenPromise: Promise<CompletedAuthToken> | undefined;\n  const entry = await update(\n    appConfig,\n    (oldEntry?: InstallationEntry): RegisteredInstallationEntry => {\n      if (!isEntryRegistered(oldEntry)) {\n        throw ERROR_FACTORY.create(ErrorCode.NOT_REGISTERED);\n      }\n\n      const oldAuthToken = oldEntry.authToken;\n      if (isAuthTokenValid(oldAuthToken)) {\n        // There is a valid token in the DB.\n        return oldEntry;\n      } else if (oldAuthToken.requestStatus === RequestStatus.IN_PROGRESS) {\n        // There already is a token request in progress.\n        tokenPromise = waitUntilAuthTokenRequest(appConfig);\n        return oldEntry;\n      } else {\n        // No token or token expired.\n        if (!navigator.onLine) {\n          throw ERROR_FACTORY.create(ErrorCode.APP_OFFLINE);\n        }\n\n        const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);\n        tokenPromise = fetchAuthTokenFromServer(appConfig, inProgressEntry);\n        return inProgressEntry;\n      }\n    }\n  );\n\n  const authToken: CompletedAuthToken = tokenPromise\n    ? await tokenPromise\n    : (entry.authToken as CompletedAuthToken);\n  return authToken.token;\n}\n\n/**\n * Call only if FID is registered and Auth Token request is in progress.\n */\nasync function waitUntilAuthTokenRequest(\n  appConfig: AppConfig\n): Promise<CompletedAuthToken> {\n  // Unfortunately, there is no way of reliably observing when a value in\n  // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n  // so we need to poll.\n\n  let entry = await updateAuthTokenRequest(appConfig);\n  while (entry.authToken.requestStatus === RequestStatus.IN_PROGRESS) {\n    // generateAuthToken still in progress.\n    await sleep(100);\n\n    entry = await updateAuthTokenRequest(appConfig);\n  }\n\n  const authToken = entry.authToken;\n  if (authToken.requestStatus === RequestStatus.NOT_STARTED) {\n    throw ERROR_FACTORY.create(ErrorCode.GENERATE_TOKEN_FAILED);\n  } else {\n    return authToken;\n  }\n}\n\n/**\n * Called only if there is a GenerateAuthToken request in progress.\n *\n * Updates the InstallationEntry in the DB based on the status of the\n * GenerateAuthToken request.\n *\n * Returns the updated InstallationEntry.\n */\nfunction updateAuthTokenRequest(\n  appConfig: AppConfig\n): Promise<RegisteredInstallationEntry> {\n  return update(\n    appConfig,\n    (oldEntry?: InstallationEntry): RegisteredInstallationEntry => {\n      if (!isEntryRegistered(oldEntry)) {\n        throw ERROR_FACTORY.create(ErrorCode.NOT_REGISTERED);\n      }\n\n      const oldAuthToken = oldEntry.authToken;\n      if (hasAuthTokenRequestTimedOut(oldAuthToken)) {\n        return {\n          ...oldEntry,\n          authToken: { requestStatus: RequestStatus.NOT_STARTED }\n        };\n      }\n\n      return oldEntry;\n    }\n  );\n}\n\nasync function fetchAuthTokenFromServer(\n  appConfig: AppConfig,\n  installationEntry: RegisteredInstallationEntry\n): Promise<CompletedAuthToken> {\n  try {\n    const authToken = await generateAuthToken(appConfig, installationEntry);\n    const updatedInstallationEntry: RegisteredInstallationEntry = {\n      ...installationEntry,\n      authToken\n    };\n    await set(appConfig, updatedInstallationEntry);\n    return authToken;\n  } catch (e) {\n    if (isServerError(e) && (e.serverCode === 401 || e.serverCode === 404)) {\n      // Server returned a \"FID not found\" or a \"Invalid authentication\" error.\n      // Generate a new ID next time.\n      await remove(appConfig);\n    } else {\n      const updatedInstallationEntry: RegisteredInstallationEntry = {\n        ...installationEntry,\n        authToken: { requestStatus: RequestStatus.NOT_STARTED }\n      };\n      await set(appConfig, updatedInstallationEntry);\n    }\n    throw e;\n  }\n}\n\nfunction isEntryRegistered(\n  installationEntry: InstallationEntry | undefined\n): installationEntry is RegisteredInstallationEntry {\n  return (\n    installationEntry !== undefined &&\n    installationEntry.registrationStatus === RequestStatus.COMPLETED\n  );\n}\n\nfunction isAuthTokenValid(authToken: AuthToken): boolean {\n  return (\n    authToken.requestStatus === RequestStatus.COMPLETED &&\n    !isAuthTokenExpired(authToken)\n  );\n}\n\nfunction isAuthTokenExpired(authToken: CompletedAuthToken): boolean {\n  const now = Date.now();\n  return (\n    now < authToken.creationTime ||\n    authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER\n  );\n}\n\n/** Returns an updated InstallationEntry with an InProgressAuthToken. */\nfunction makeAuthTokenRequestInProgressEntry(\n  oldEntry: RegisteredInstallationEntry\n): RegisteredInstallationEntry {\n  const inProgressAuthToken: InProgressAuthToken = {\n    requestStatus: RequestStatus.IN_PROGRESS,\n    requestTime: Date.now()\n  };\n  return {\n    ...oldEntry,\n    authToken: inProgressAuthToken\n  };\n}\n\nfunction hasAuthTokenRequestTimedOut(authToken: AuthToken): boolean {\n  return (\n    authToken.requestStatus === RequestStatus.IN_PROGRESS &&\n    authToken.requestTime + PENDING_TIMEOUT_MS < Date.now()\n  );\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app-types';\nimport { extractAppConfig } from '../helpers/extract-app-config';\nimport { getInstallationEntry } from '../helpers/get-installation-entry';\nimport { refreshAuthToken } from '../helpers/refresh-auth-token';\nimport { RequestStatus } from '../interfaces/installation-entry';\n\nexport async function getId(app: FirebaseApp): Promise<string> {\n  const appConfig = extractAppConfig(app);\n  const { installationEntry, registrationPromise } = await getInstallationEntry(\n    appConfig\n  );\n\n  if (registrationPromise) {\n    // Suppress registration errors as they are not a problem for getId.\n    registrationPromise.catch(() => {});\n  }\n\n  if (installationEntry.registrationStatus === RequestStatus.COMPLETED) {\n    // If the installation is already registered, update the authentication\n    // token if needed. Suppress errors as they are not relevant to getId.\n    refreshAuthToken(appConfig).catch(() => {});\n  }\n\n  return installationEntry.fid;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app-types';\nimport { extractAppConfig } from '../helpers/extract-app-config';\nimport { getInstallationEntry } from '../helpers/get-installation-entry';\nimport { refreshAuthToken } from '../helpers/refresh-auth-token';\nimport { AppConfig } from '../interfaces/app-config';\nimport { RequestStatus } from '../interfaces/installation-entry';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\n\nexport async function getToken(app: FirebaseApp): Promise<string> {\n  const appConfig = extractAppConfig(app);\n\n  await completeInstallationRegistration(appConfig);\n\n  // At this point we either have a Registered Installation in the DB, or we've\n  // already thrown an error.\n  return refreshAuthToken(appConfig);\n}\n\nasync function completeInstallationRegistration(\n  appConfig: AppConfig\n): Promise<void> {\n  const { installationEntry, registrationPromise } = await getInstallationEntry(\n    appConfig\n  );\n\n  if (registrationPromise) {\n    // A createInstallation request is in progress. Wait until it finishes.\n    await registrationPromise;\n  } else if (installationEntry.registrationStatus !== RequestStatus.COMPLETED) {\n    // Installation ID can't be registered.\n    throw ERROR_FACTORY.create(ErrorCode.CREATE_INSTALLATION_FAILED);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppConfig } from '../interfaces/app-config';\nimport { RegisteredInstallationEntry } from '../interfaces/installation-entry';\nimport {\n  getErrorFromResponse,\n  getHeadersWithAuth,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\n\nexport async function deleteInstallation(\n  appConfig: AppConfig,\n  installationEntry: RegisteredInstallationEntry\n): Promise<void> {\n  const endpoint = getDeleteEndpoint(appConfig, installationEntry);\n\n  const headers = getHeadersWithAuth(appConfig, installationEntry);\n  const request: RequestInit = {\n    method: 'DELETE',\n    headers\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (!response.ok) {\n    throw await getErrorFromResponse('Delete Installation', response);\n  }\n}\n\nfunction getDeleteEndpoint(\n  appConfig: AppConfig,\n  { fid }: RegisteredInstallationEntry\n): string {\n  return `${getInstallationsEndpoint(appConfig)}/${fid}`;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app-types';\nimport { deleteInstallation as deleteInstallationRequest } from '../api/delete-installation';\nimport { extractAppConfig } from '../helpers/extract-app-config';\nimport { remove, update } from '../helpers/idb-manager';\nimport {\n  InProgressInstallationEntry,\n  InstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\n\nexport async function deleteInstallation(app: FirebaseApp): Promise<void> {\n  const appConfig = extractAppConfig(app);\n\n  const entry = await update(appConfig, (oldEntry?: InstallationEntry):\n    | InProgressInstallationEntry\n    | RegisteredInstallationEntry\n    | undefined => {\n    if (oldEntry && oldEntry.registrationStatus === RequestStatus.NOT_STARTED) {\n      // Delete the unregistered entry without sending a deleteInstallation request.\n      return undefined;\n    }\n    return oldEntry;\n  });\n\n  if (entry) {\n    if (entry.registrationStatus === RequestStatus.IN_PROGRESS) {\n      // Can't delete while trying to register.\n      throw ERROR_FACTORY.create(ErrorCode.DELETE_PENDING_REGISTRATION);\n    } else if (entry.registrationStatus === RequestStatus.COMPLETED) {\n      if (!navigator.onLine) {\n        throw ERROR_FACTORY.create(ErrorCode.APP_OFFLINE);\n      } else {\n        await deleteInstallationRequest(appConfig, entry);\n        await remove(appConfig);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport firebase from '@firebase/app';\nimport {\n  _FirebaseNamespace,\n  FirebaseServiceFactory\n} from '@firebase/app-types/private';\nimport { FirebaseInstallations } from '@firebase/installations-types';\n\nimport { deleteInstallation, getId, getToken } from './functions';\nimport { extractAppConfig } from './helpers/extract-app-config';\n\nexport function registerInstallations(instance: _FirebaseNamespace): void {\n  const installationsName = 'installations';\n\n  const factoryMethod: FirebaseServiceFactory = app => {\n    // Throws if app isn't configured properly.\n    extractAppConfig(app);\n\n    return {\n      app,\n      getId: () => getId(app),\n      getToken: () => getToken(app),\n      delete: () => deleteInstallation(app)\n    };\n  };\n\n  instance.INTERNAL.registerService(installationsName, factoryMethod);\n}\n\nregisterInstallations(firebase as _FirebaseNamespace);\n\n/**\n * Define extension behavior of `registerInstallations`\n */\ndeclare module '@firebase/app-types' {\n  interface FirebaseNamespace {\n    installations(app?: FirebaseApp): FirebaseInstallations;\n  }\n  interface FirebaseApp {\n    installations(): FirebaseInstallations;\n  }\n}\n"],"names":["deleteInstallation","deleteInstallationRequest"],"mappings":"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"}